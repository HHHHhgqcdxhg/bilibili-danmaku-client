{"version":3,"sources":["../src/encoding.js"],"names":["require","Buffer","isEqual","HeartbeatSector","HeartbeatAckSector","DataSector","InitSector","InitAckSector","sector2meta","Map","set","control","type","encodeOne","sector","content","encode","metadata","get","Object","getPrototypeOf","constructor","header","alloc","writeInt32BE","length","concat","decodeOne","buf","offset","len","readInt32BE","entry","Array","from","entries","find","value","Error","JSON","stringify","decode","slice","newOffset","sectors","map","push","toString","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * The encoding module.\r\n * This module implements the protocol used by Bilibili Live Danmaku Client & Server\r\n * in the WebSocket binary frames. In particular, the encoding from string to binary\r\n * data is implemented here.\r\n *\r\n * DETAILS\r\n * A binary frame in the WebSocket between the client and the server constructs of\r\n * 1 or more sectors. Every SECTOR has a 16-byte HEADER part and a CONTENT part of\r\n * arbitrary length.\r\n * Let the length of the CONTENT part be LEN (in bytes), then the HEADER part is\r\n * encoded as follows: (Note that all definitions are based on guesswork, not actual\r\n * standards, and might change in the future)\r\n * BYTES 0                   1\r\n *       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\r\n *      +-------+-+-+-+-+-----+-+-----+-+\r\n *      |  LEN  |0|1|0|C|  0  |T|  0  |C|\r\n *      |  +16  |0|0|0|F|  0  |Y|  0  |F|\r\n *      +-------+-+-+-+-+-----+-+-----+-+\r\n * CF (Control Flag): 1 if this SECTOR is a control sector (heartbeat & ack,\r\n * initialilzation & ack), 0 if not.\r\n * TY (Type): The type of this SECTOR, known values are:\r\n *    02: Heartbeat sector.\r\n *    03: Heartbeat ACK sector.\r\n *    05: JSON data sector.\r\n *    07: Initialization sector.\r\n *    08. Initialization ACK sector.\r\n *\r\n * Since one frame can contain multiple sectors, during decoding the first 4 bytes\r\n * of the HEADER part is used to determint the length of each SECTOR, so that the next\r\n * SECTOR can be found where the previous one ends. During encoding, sectors are simply\r\n * concantenated.\r\n *\r\n * For more information about what each sector does, see sectors.js.\r\n *\r\n * @module biliDanmakuClient/encoding\r\n */\r\n\r\nconst { Buffer } = require('buffer');\r\nconst { isEqual } = require('lodash');\r\n\r\nconst { HeartbeatSector, HeartbeatAckSector, DataSector, InitSector, InitAckSector } = require('./sectors');\r\n\r\n/**\r\n * A Map beteen constructors of different sector types and the corresponding metadata.\r\n */\r\nconst sector2meta = new Map();\r\nsector2meta.set(HeartbeatSector, { control: true, type: 0x02 });\r\nsector2meta.set(HeartbeatAckSector, { control: true, type: 0x03 });\r\nsector2meta.set(DataSector, { control: false, type: 0x05 });\r\nsector2meta.set(InitSector, { control: true, type: 0x07 });\r\nsector2meta.set(InitAckSector, { control: true, type: 0x08 });\r\n\r\n/**\r\n * Encode one Sector into Buffer.\r\n * It assumes that Object.getPrototypeOf(sector).constructor exists and is the correct\r\n * constructor. Otherwise, the behaviour is undefined.\r\n *\r\n * @param {Sector} sector The Sector to encode.\r\n */\r\nconst encodeOne = (sector) => {\r\n    const content = sector.encode();\r\n    // assume constructor exists\r\n    const metadata = sector2meta.get(Object.getPrototypeOf(sector).constructor);\r\n\r\n    const header = Buffer.alloc(16);\r\n    header.writeInt32BE(content.length + 16, 0);\r\n    header[5] = 0x10;\r\n    header[7] = metadata.control ? 0x01 : 0x00;\r\n    header[11] = metadata.type;\r\n    header[15] = metadata.control ? 0x01 : 0x00;\r\n\r\n    return Buffer.concat([header, content]);\r\n};\r\n\r\n/**\r\n * Decode one Sector and calculate the offset of the next Sector.\r\n * This method assumes that the buffer is sufficient for the current Sector. Otherwise,\r\n * the behavior is undefined.\r\n * The return value is:\r\n * {\r\n *     sector: {Sector} The decoded sector.\r\n *     newOffset: {Number} The new offset.\r\n * }\r\n * Implementation should use newOffset to replace the offset passed to decodeOne directly.\r\n *\r\n * @param {Buffer} buf The Buffer to decode.\r\n * @param {Number} offset The starting offset to decode.\r\n */\r\nconst decodeOne = (buf, offset) => {\r\n    // extract metadata from header\r\n    const len = buf.readInt32BE(offset) - 16;\r\n    const metadata = {\r\n        control: buf[offset + 7] === 0x01,\r\n        type: buf[offset + 11],\r\n    };\r\n\r\n    // find type\r\n    const entry = Array.from(sector2meta.entries()).find(([, value]) => isEqual(value, metadata));\r\n    if (typeof entry === 'undefined') {\r\n        throw new Error(`Unrecognized header: ${JSON.stringify(metadata)}`);\r\n    }\r\n    const type = entry[0];\r\n\r\n    // construct sector object\r\n    return {\r\n        sector: type.decode(type, buf.slice(offset + 16, offset + len + 16)),\r\n        newOffset: offset + len + 16,\r\n    };\r\n};\r\n\r\n/**\r\n * Encode the given sectors into a Buffer.\r\n * The sectors will be encoded in order.\r\n * The returned Buffer should be passed directly to WebSocket.send().\r\n *\r\n * @param {Sector[]} sectors The sectors to encode.\r\n * @returns {Buffer} The encoded Buffer.\r\n */\r\nconst encode = (...sectors) => Buffer.concat(sectors.map(encodeOne));\r\n\r\n/**\r\n * Decode the given Buffer and return the sectors.\r\n * This method assumes that the input Buffer is valid. On invalid input, an Error\r\n * might be thrown.\r\n *\r\n * @param {Buffer} buf The Buffer to decode.\r\n * @returns {Sector[]} The decoded sectors.\r\n */\r\nconst decode = (buf) => {\r\n    const sectors = [];\r\n\r\n    let offset = 0;\r\n    while (offset < buf.length) {\r\n        const { sector, newOffset } = decodeOne(buf, offset);\r\n        sectors.push(sector);\r\n        offset = newOffset;\r\n    }\r\n\r\n    if (offset !== buf.length) {\r\n        throw new Error(`Invalid Buffer: len=${buf.length}, off=${offset}, buf=${buf.toString('hex')}.`);\r\n    }\r\n\r\n    return sectors;\r\n};\r\n\r\nmodule.exports = { encode, decode };\r\n"],"file":"encoding.js"}
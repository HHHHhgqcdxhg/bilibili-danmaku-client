{"version":3,"sources":["../src/SectorSocket.js"],"names":["WebSocket","require","EventEmitter","encode","decode","SectorSocket","url","options","ws","undefined","on","onMessage","bind","forEach","eventName","args","emit","use","middleware","data","onBuffer","buf","sector","Buffer","Array","filter","el","send","terminate","module","exports"],"mappings":";;;;;;;;AAAA,IAAMA,YAAYC,QAAQ,eAAR,CAAlB;;AACA,IAAMC,eAAeD,QAAQ,QAAR,CAArB;;eAE2BA,QAAQ,YAAR,C;IAAnBE,M,YAAAA,M;IAAQC,M,YAAAA,M;AAEhB;;;;;;;;;;;;;IAWMC,Y;;;;;AACF;;;;;;;;;;;;;AAaA,wBAAYC,GAAZ,EAAiBC,OAAjB,EAA+B;AAAA;;AAAA,QAAdA,OAAc;AAAdA,aAAc,GAAJ,EAAI;AAAA;;AAC3B;AAEA,QAAMC,KAAK,IAAIR,SAAJ,CAAcM,GAAd,EAAmBG,SAAnB,EAA8BF,OAA9B,CAAX;AACA,UAAKC,EAAL,GAAUA,EAAV;AACAA,OAAGE,EAAH,CAAM,SAAN,EAAiB,MAAKC,SAAL,CAAeC,IAAf,uDAAjB;AACA,KAAC,MAAD,EAAS,OAAT,EAAkB,OAAlB,EAA2BC,OAA3B,CAAmC,UAACC,SAAD,EAAe;AAC9CN,SAAGE,EAAH,CAAMI,SAAN,EAAiB;AAAA;;AAAA,0CAAIC,IAAJ;AAAIA,cAAJ;AAAA;;AAAA,eAAa,iBAAKC,IAAL,gBAAUF,SAAV,SAAwBC,IAAxB,EAAb;AAAA,OAAjB;AACH,KAFD;AAN2B;AAS9B;AAED;;;;;;;;;;;;;;;;;;SAcAE,G,gBAAIC,U,EAAY;AACZA,eAAW,IAAX;AACH,G;AAED;;;;;;;;;SAOAP,S,sBAAUQ,I,EAAM;AAAA;;AACZ,QAAMC,WAAW,SAAXA,QAAW;AAAA,aAAOhB,OAAOiB,GAAP,EAAYR,OAAZ,CAAoB;AAAA,eAAU,OAAKG,IAAL,CAAU,QAAV,EAAoBM,MAApB,CAAV;AAAA,OAApB,CAAP;AAAA,KAAjB;;AACA,QAAIH,gBAAgBI,MAApB,EAA4BH,SAASD,IAAT,EAA5B,KACK,IAAIA,gBAAgBK,KAApB,EAA2B;AAC5BL,WAAKM,MAAL,CAAY;AAAA,eAAMC,cAAcH,MAApB;AAAA,OAAZ,EAAwCV,OAAxC,CAAgDO,QAAhD;AACH;AACJ,G;AAED;;;;;;;;;SAOAO,I,mBAAiB;AACb,SAAKnB,EAAL,CAAQmB,IAAR,CAAaxB,+BAAb;AACH,G;AAED;;;;;;;;SAMAyB,S,wBAAY;AACR,SAAKpB,EAAL,CAAQoB,SAAR;AACH,G;;;EA7EsB1B,Y;;AAgF3B2B,OAAOC,OAAP,GAAiBzB,YAAjB","sourcesContent":["const WebSocket = require('x-platform-ws');\r\nconst EventEmitter = require('events');\r\n\r\nconst { encode, decode } = require('./encoding');\r\n\r\n/**\r\n * SectorSocket is a wrapper WebSocket transfering only Sectors, by conforming to the\r\n * internal protocols of the Bilibili Live Websocket Interface.\r\n * Sectors are defined in ./sectors.js.\r\n *\r\n * EVENTS\r\n * 'open': When this socket is opened.\r\n * 'close': When this socket is closed. arg(s): code, reason\r\n * 'error': When the server sends an error. arg(s): error\r\n * 'sector': When a sector is received. arg(s): sector\r\n */\r\nclass SectorSocket extends EventEmitter {\r\n    /**\r\n     * Construct a new SectorSocket object, connecting to the given url.\r\n     * The 'options' parameter is used to enable customization of the WebSocket connection,\r\n     * like setting the proxy, adding headers, etc.. For more details, see documentation\r\n     * of ws.\r\n     * Note that the WebSocket will be opening after this constructor returns, however, due\r\n     * to the single-thread nature of Javascript, it is still possible to add middlewares\r\n     * with use.\r\n     *\r\n     * @param {string} url The url to connect to.\r\n     * @param {*} options The options used to customize the WebSocket connection, optional.\r\n     * @see use\r\n     */\r\n    constructor(url, options = {}) {\r\n        super();\r\n\r\n        const ws = new WebSocket(url, undefined, options);\r\n        this.ws = ws;\r\n        ws.on('message', this.onMessage.bind(this));\r\n        ['open', 'close', 'error'].forEach((eventName) => {\r\n            ws.on(eventName, (...args) => this.emit(eventName, ...args));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Use the middleware for the current SectorSocket.\r\n     * This method should be called directly after the SectorSocket() constructor.\r\n     * Middlewares are used to add functionality to this plain socket, while enhancing\r\n     * modularization. The idea was taken from the Express middlewares.\r\n     * Middlewares are functions, invoked only once, at the invocation of use(), taking\r\n     * the current SectorSocket object as argument.\r\n     * It is typical to add listeners in middlewares, since SectorSocket extends\r\n     * EventEmitter.\r\n     * It is safe to assume that the SectorSocket is not yet opened nor closed then the\r\n     * middleware is applied.\r\n     *\r\n     * @param {Function} middleware The middleware to use.\r\n     */\r\n    use(middleware) {\r\n        middleware(this);\r\n    }\r\n\r\n    /**\r\n     * Called on the 'message' event of the underlying WebSocket, decoding Buffer or\r\n     * Buffer[] data to sectors and emitting 'sector' events.\r\n     * This is an internal method.\r\n     *\r\n     * @param {string|Buffer|Buffer[]} data The data of the message.\r\n     */\r\n    onMessage(data) {\r\n        const onBuffer = buf => decode(buf).forEach(sector => this.emit('sector', sector));\r\n        if (data instanceof Buffer) onBuffer(data);\r\n        else if (data instanceof Array) {\r\n            data.filter(el => el instanceof Buffer).forEach(onBuffer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send the given sectors, one by one.\r\n     * The sectors are first encoded into Buffers and then send by the WebSocket.\r\n     * For more details about the encoding process, see encoding.js\r\n     *\r\n     * @param {Sector[]} sectors The sectors to send.\r\n     */\r\n    send(...sectors) {\r\n        this.ws.send(encode(...sectors));\r\n    }\r\n\r\n    /**\r\n     * Terminate the socket.\r\n     * Note that an 'close' event will be emitted after terminate().\r\n     * Behavior of calling other methods on the SectorSocket instance after terminate is\r\n     * undefined and should be avoided.\r\n     */\r\n    terminate() {\r\n        this.ws.terminate();\r\n    }\r\n}\r\n\r\nmodule.exports = SectorSocket;\r\n"],"file":"SectorSocket.js"}
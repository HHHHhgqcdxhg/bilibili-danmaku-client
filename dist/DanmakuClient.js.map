{"version":3,"sources":["../src/DanmakuClient.js"],"names":["EventEmitter","require","defaultsDeep","log","SectorSocket","Middleware","all","manageLifecycle","ws","conf","client","checkTerminate","state","setState","on","closeAction","keepAlive","enabled","reconnStr","reconnectInterval","toFixed","url","reconnect","connect","setTimeout","forEach","name","once","terminate","defaultConf","room","uid","middlewares","options","rejectUnauthorized","DanmakuClient","socket","middleware","config","start","indexOf","emit","module","exports"],"mappings":"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","sourcesContent":["const EventEmitter = require('events');\r\nconst { defaultsDeep } = require('lodash');\r\nconst log = require('debug')('bilibili-danmaku-client/client');\r\n\r\nconst SectorSocket = require('./SectorSocket');\r\nconst { Middleware, all } = require('./middlewares');\r\n\r\n// TODO: make this more elegant.\r\n/**\r\n * The Middleware that manages the lifecycle of DanmakuClient.\r\n * This middleware is necessary for DanmakuClient to work correctly and is so closely\r\n * related to the internal mechanics of DanmakuClient so that it must be placed in\r\n * DanmakuClient.js.\r\n *\r\n * Lifecycle of DanmakuClient instance are described with their state attribute.\r\n * A list of all possible lifecycle states are:\r\n * 'idle': When the client is not yet started.\r\n * 'connecting': When the client is started and trying to connect to the remote server.\r\n * 'opened': When the WebSocket connection is opened and ready to send and receive data.\r\n * 'reconnecting': When the DanmakuClient is in keepAlive mode and waiting to reconnect.\r\n * 'terminating': When the termination is request and waiting for the actual termination\r\n *     to take place.\r\n * 'terminated': When the client is terminated.\r\n *\r\n * Each DanmakuClient has a mode, keepAlive or non-keepAlive, configured by setting\r\n * conf.keepAlive.enabled.\r\n * In non-keepAlive mode, the client terminates directly after the WebSocket is closed\r\n * or gets an error. In keepAlive mode, the client waits for some time interval and then\r\n * tries to reconnecto to the server again.\r\n *\r\n * State transitions are as follows:\r\n * Start from 'idle'.\r\n * 'idle' -> 'connecting' on start()\r\n * 'connecting' -> 'terminated' on non-keepAlive and connection error\r\n *              -> 'opened' on successful connection\r\n *              -> 'terminating' on terminate()\r\n * 'opened' -> 'terminated' on non-keepAlive and connection close / error\r\n *          -> 'reconnecting' on keepAlive and connection close / error\r\n *          -> 'terminating' on terminate()\r\n * 'reconnecting' -> 'connecting' after some time interval\r\n *                -> 'terminating' on terminate()\r\n * 'terminating' -> 'terminated' on connection close / next setState() call\r\n * 'terminated' is the final state.\r\n */\r\nconst manageLifecycle = new Middleware(\r\n    (ws, conf, client) => {\r\n        // If terminate is requested, switch to terminated and return false, else return true.\r\n        const checkTerminate = () => {\r\n            if (client.state === 'terminating') {\r\n                client.setState('terminated');\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        if (!checkTerminate()) return;\r\n        client.setState('connecting');\r\n        ws.on('open', () => { if (checkTerminate()) client.setState('opened'); });\r\n\r\n        const closeAction = conf.keepAlive.enabled ? () => {\r\n            if (!checkTerminate()) return;\r\n            if (client.state === 'reconnecting') return;\r\n\r\n            const reconnStr = conf.keepAlive.reconnectInterval.toFixed(0);\r\n            log(`Connection to ${conf.url} closed / got an error while in keepAlive mode, therefore DanmakuClient will auto-reconnect after ${reconnStr} seconds.`);\r\n            log('To terminate the client, call terminate().');\r\n            client.setState('reconnecting');\r\n\r\n            const reconnect = () => { if (checkTerminate()) client.connect(); };\r\n            setTimeout(reconnect, conf.keepAlive.reconnectInterval);\r\n        } : () => { if (checkTerminate()) client.setState('terminated'); };\r\n        ['close', 'error'].forEach(name => ws.on(name, closeAction));\r\n\r\n        client.once('terminate', () => ws.terminate());\r\n    }, {\r\n        keepAlive: {\r\n            enabled: true,\r\n            reconnectInterval: 5000,\r\n        },\r\n    },\r\n);\r\n\r\nconst defaultConf = {\r\n    url: 'wss://broadcastlv.chat.bilibili.com:2245/sub',\r\n    room: 1,\r\n    uid: 0, // without a user\r\n    middlewares: all, // use all middlwares\r\n    options: { rejectUnauthorized: false }, // avoid unauthorized error\r\n};\r\n\r\nclass DanmakuClient extends EventEmitter {\r\n    /**\r\n     * Constructs the DanmakuClient instance.\r\n     * After initialization, the state of this DanmakuClient is set to 'idle',\r\n     * applications should call start() to actually start the client.\r\n     *\r\n     * @param {*} conf The conf object.\r\n     */\r\n    constructor(conf) {\r\n        super();\r\n        this.conf = defaultsDeep(conf, defaultConf);\r\n        this.state = 'idle';\r\n    }\r\n\r\n    /**\r\n     * Build connection to the Danmaku server, configurating all the middlewares.\r\n     * The socket is not saved in the DanmakuClient interface, applications should use\r\n     * middlewares to add functionality.\r\n     * This is an internal method.\r\n     * For details of how this methods works, see documentation of manageLifecycle.\r\n     */\r\n    connect() {\r\n        const socket = new SectorSocket(this.conf.url, this.conf.options);\r\n        [...this.conf.middlewares, manageLifecycle]\r\n            .forEach(middleware => middleware.config(socket, this.conf, this));\r\n    }\r\n\r\n    /**\r\n     * Start this DanmakuClient.\r\n     * The DanmakuClient instance can be started only when its state is 'idle'.\r\n     * For details of how this methods works, see documentation of manageLifecycle.\r\n     */\r\n    start() {\r\n        if (this.state === 'idle') this.connect();\r\n    }\r\n\r\n    /**\r\n     * Terminate this DanmakuClient.\r\n     * On terminate(), the client isn't terminated immediately. In fact, it first\r\n     * switches to 'terminating' state, and will eventually switch to 'terminated'\r\n     * state after some time.\r\n     * If the current state is 'terminating', 'terminated' or 'idle', nothing happens.\r\n     * For details of how this methods works, see documentation of manageLifecycle.\r\n     */\r\n    terminate() {\r\n        if (['terminating', 'terminated', 'idle'].indexOf(this.state) !== -1) return;\r\n        this.setState('terminating');\r\n        this.emit('terminate');\r\n    }\r\n\r\n    /**\r\n     * Set the current state of this DanmakuClient.\r\n     * States MUST be switched using this method, except in the constructor. setState()\r\n     * sets the state and emits an event with the name being the new state so that\r\n     * applications can listen to the lifecycle changes of the client.\r\n     * This is an internal method.\r\n     *\r\n     * @param {string} state The state to switch to.\r\n     */\r\n    setState(state) {\r\n        if (this.state !== state) {\r\n            this.state = state;\r\n            this.emit(state);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = DanmakuClient;\r\n"],"file":"DanmakuClient.js"}